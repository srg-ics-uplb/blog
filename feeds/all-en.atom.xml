<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Lost Packets</title><link href="https://srg-ics-uplb.github.io/blog/" rel="alternate"></link><link href="https://srg-ics-uplb.github.io/blog/feeds/all-en.atom.xml" rel="self"></link><id>https://srg-ics-uplb.github.io/blog/</id><updated>2020-02-03T00:00:00+08:00</updated><entry><title>Eliens' First Quest of 2020: Algolympics</title><link href="https://srg-ics-uplb.github.io/blog/eliens-first-quest-of-2020-algolympics.html" rel="alternate"></link><published>2020-02-03T00:00:00+08:00</published><updated>2020-02-03T00:00:00+08:00</updated><author><name>Clinton E. Poserio</name></author><id>tag:srg-ics-uplb.github.io,2020-02-03:/blog/eliens-first-quest-of-2020-algolympics.html</id><summary type="html">&lt;p&gt;Eliens, the moniker of the UPLB Competitive Programming team, is back in action as they qualify for the Final Round of Algolympics 2020, a programming contest organized by &lt;a class="reference external" href="https://www.facebook.com/upacm/"&gt;ACM-UP Diliman Student Chapter, Inc.&lt;/a&gt;. Four teams from Eliens, with three individuals each, were formed and registered to the Online Elimination Round …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Eliens, the moniker of the UPLB Competitive Programming team, is back in action as they qualify for the Final Round of Algolympics 2020, a programming contest organized by &lt;a class="reference external" href="https://www.facebook.com/upacm/"&gt;ACM-UP Diliman Student Chapter, Inc.&lt;/a&gt;. Four teams from Eliens, with three individuals each, were formed and registered to the Online Elimination Round of Algolympics 2020 last January 17-27, 2020. The ten-day long contest was held on the &lt;a class="reference external" href="https://codeforces.com/group/fDKsZH3HKS/contest/266086/standings/groupmates/true"&gt;Codeforces&lt;/a&gt; platform, and was participated by 83 teams[1]_ from 20 different universities in the Philippines. However, only the top 20  teams  from all the participating teams and only the top three teams from each university are qualified to join the final round. With the skills of the participating students, all three slots for UPLB were filled; three teams from Eliens qualified to the Final Round of Algolympics 2020.&lt;/p&gt;
&lt;p&gt;Keep posted as the Eliens, together with their coach, Clinton Poserio, prepares for the Final Round of Algolympics, which will be held on February 22, 2020 at the UP Alumni Engineers Centennial Hall, UP Diliman, Quezon City.&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="id1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[1]&lt;/td&gt;&lt;td&gt;there are two additional international teams.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content><category term="News"></category></entry><entry><title>Fuzzing: Hack, Art, and Science</title><link href="https://srg-ics-uplb.github.io/blog/fuzzing-hack-art-and-science.html" rel="alternate"></link><published>2020-01-27T00:00:00+08:00</published><updated>2020-01-27T00:00:00+08:00</updated><author><name>Joseph Anthony C. Hermocilla</name></author><id>tag:srg-ics-uplb.github.io,2020-01-27:/blog/fuzzing-hack-art-and-science.html</id><summary type="html">&lt;p&gt;A program usually accepts input, performs operations on the input, and produces output.  Incorrect processing of input can lead to security vulnerabilities, such as buffer overflow. Depending on the input, the program may not perform the desired operation. An attacker can craft a specialized input that exploits the vulnerability to …&lt;/p&gt;</summary><content type="html">&lt;p&gt;A program usually accepts input, performs operations on the input, and produces output.  Incorrect processing of input can lead to security vulnerabilities, such as buffer overflow. Depending on the input, the program may not perform the desired operation. An attacker can craft a specialized input that exploits the vulnerability to take control of the machine running the vulnerable software.&lt;/p&gt;
&lt;p&gt;This paper [&lt;a class="reference internal" href="#godefroid2020"&gt;GODEFROID2020&lt;/a&gt;] gives an overview of fuzzing as a way to detect security vulnerabilities. Other approaches mentioned in the paper include the use of static program analyzers and manual code inspection. Fuzzing tests the behavior of a program against all, or a subset, of possible inputs to identify security vulnerabilities. It is an automated testing technique since there is a large set of possible inputs to a program.&lt;/p&gt;
&lt;p&gt;The paper discussed three fuzzing techniques. The first technique is called Blackbox Fuzzing. This technique uses well-formed inputs, mutates them, then use the mutated input to test the software.&lt;/p&gt;
&lt;p&gt;The second technique is Grammar-Based Fuzzing. This technique is useful if the input follows some form of structured formats such as JSON or XML. In this approach, the tester provides a grammar specifying the format. The fuzzer then generates input based on the provided grammar.&lt;/p&gt;
&lt;p&gt;The last technique is called Whitebox Fuzzing. This technique is more advanced since it uses dynamic symbolic execution. It gathers constraints on inputs as it executes a program from conditional branches. The constraints are negated and solved using a constraint solver. The solutions are then mapped to new inputs to pass through other execution paths in a program. SAGE is an example tool for Whitebox Fuzzing described in the paper.&lt;/p&gt;
&lt;p&gt;The conclusion is that the fuzzing technique to use depends on the type of program being tested. Programs that use binary input formats are best tested with Blackbox Fuzzing or Whitebox Fuzzing. Programs with more structured formats will benefit from Grammar-Based fuzzing.&lt;/p&gt;
&lt;table class="docutils citation" frame="void" id="godefroid2020" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[GODEFROID2020]&lt;/td&gt;&lt;td&gt;Patrice Godefroid. 2020. Fuzzing: hack, art, and science. Commun. ACM 63, 2 (January 2020), 70–76. DOI:https://doi.org/10.1145/3363824&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content><category term="Paper Review"></category></entry><entry><title>Cloud Benchmarking for Maximising Performance of Scientific Applications</title><link href="https://srg-ics-uplb.github.io/blog/cloud-benchmarking-for-maximising-performance-of-scientific-applications.html" rel="alternate"></link><published>2019-04-29T00:00:00+08:00</published><updated>2019-04-29T00:00:00+08:00</updated><author><name>Joseph Anthony C. Hermocilla</name></author><id>tag:srg-ics-uplb.github.io,2019-04-29:/blog/cloud-benchmarking-for-maximising-performance-of-scientific-applications.html</id><summary type="html">&lt;p&gt;It is quite difficult for users to select VM configurations to optimize the
performance of their applications, especially if there are a lot of choices.
For example, if I want to run computational chemistry app, I need to make a decision
whether to use a VM with 1 VCPU and …&lt;/p&gt;</summary><content type="html">&lt;p&gt;It is quite difficult for users to select VM configurations to optimize the
performance of their applications, especially if there are a lot of choices.
For example, if I want to run computational chemistry app, I need to make a decision
whether to use a VM with 1 VCPU and 2GB RAM or a VM with 2 VCPUs and 4GB RAM.&lt;/p&gt;
&lt;p&gt;Cloud providers run benchmarks to measure the performance of various VM configurations for applications.
However, these benchmarks are done independent of the application to be deployed. Most likely because
providers have no knowledge of what application will be deployed.&lt;/p&gt;
&lt;p&gt;This paper [&lt;a class="reference internal" href="#varghese2019"&gt;VARGHESE2019&lt;/a&gt;] addresses these issues by introducing an application-aware benchmarking
methodology. The main hypothesis presented in the paper is that by taking into account application
requirements in addition to benchmarking data, VMs can be ranked in order of performance and
cost-effectiveness to maximize performance. Although there are different kinds of applications
that can be run in the cloud, the paper focused on high-performance computing applications with
the goal of minimizing execution time to minimize costs. (Running applications in the cloud is
usually charged per hour.) The authors validated they results against real-world applications.
The following are the steps in the proposed methodology.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Capture attributes of cloud VMs&lt;/li&gt;
&lt;li&gt;Group attributes of cloud VMs&lt;/li&gt;
&lt;li&gt;Benckmark cloud VMs&lt;/li&gt;
&lt;li&gt;Normalize attribute groups&lt;/li&gt;
&lt;li&gt;Provide weights to groups&lt;/li&gt;
&lt;li&gt;Rank cloud VMs&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Steps 5-6 are repeated for each deployment.&lt;/p&gt;
&lt;p&gt;In Step 2, the following are the identified attribute groups:
- memory and process
- local communication
- computation
- storage&lt;/p&gt;
&lt;p&gt;As for the benchmarking part, the researchers used bonnie++, lmbench, and sysbench.&lt;/p&gt;
&lt;p&gt;It is worth noting that this paper did not consider inter-VM communication. The
local communication is between the cores in the VM only. Perhaps a future work will
be to consider inter-VM communication in the methodology.&lt;/p&gt;
&lt;table class="docutils citation" frame="void" id="varghese2019" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[VARGHESE2019]&lt;/td&gt;&lt;td&gt;Varghese, B., Akgun, O., Miguel, I., Thai, L., &amp;amp; Barker, A. (2019). Cloud Benchmarking for Maximising Performance of Scientific Applications. IEEE Transactions on Cloud Computing, 7(1), 170–182.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content><category term="Paper Review"></category></entry><entry><title>Lock–Unlock: Is That All? A Pragmatic Analysis of Locking in Software Systems</title><link href="https://srg-ics-uplb.github.io/blog/lock-unlock-is-that-all-a-pragmatic-analysis-of-locking-in-software-systems.html" rel="alternate"></link><published>2019-04-14T00:00:00+08:00</published><updated>2019-04-14T00:00:00+08:00</updated><author><name>Joseph Anthony C. Hermocilla</name></author><id>tag:srg-ics-uplb.github.io,2019-04-14:/blog/lock-unlock-is-that-all-a-pragmatic-analysis-of-locking-in-software-systems.html</id><summary type="html">&lt;p&gt;Most processors nowadays are multi-core processors to take advantage of parallel processing.
Associated with parallel processing is the synchronization problem wherein locks are extensively
used. This paper &lt;a class="citation-reference" href="#guerraoui2019" id="id1"&gt;[GUERRAOUI2019]&lt;/a&gt; argues that despite the large amount of available choices for
lock algorithms, developers do not have a comprehensive guide to select an …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Most processors nowadays are multi-core processors to take advantage of parallel processing.
Associated with parallel processing is the synchronization problem wherein locks are extensively
used. This paper &lt;a class="citation-reference" href="#guerraoui2019" id="id1"&gt;[GUERRAOUI2019]&lt;/a&gt; argues that despite the large amount of available choices for
lock algorithms, developers do not have a comprehensive guide to select an algorithm. The paper also
asserts that most research on lock algorithms are limited to mutex locks and rarely consider other
techniques like trylocks and condition variables. In addition, most evaluation of lock algorithms
use workload that are specific to the design of the lock. Lastly, evaluation is focused only on throughput
neglecting energy efficiency and tail latency.&lt;/p&gt;
&lt;p&gt;The main contribution of this paper is a broad performance study of lock algorithms. Specifically,
28 state-of-the-art algorithms were studied and applied to 40 applications. The experiments where
conducted of 4 different multi-core machines. As mentioned, this study considered energy efficiency and
tail latency, in addition to throughtput, as metrics in the evaluation. In the paper, the authors
claimed that it is really difficult to choose a well-performing lock for an application because of
several factors: workload, hardware, degree of parallelism, number of locks, how they are used, interaction
between the application and the CPU scheduler, and metric. The authors also developed a library called LiTL
used for testing the applications.&lt;/p&gt;
&lt;p&gt;The authors have the following observations as a result of their study&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Trylocks and condition variables should also be considered&lt;/li&gt;
&lt;li&gt;Memory footprint of lock algorithms affect performance&lt;/li&gt;
&lt;li&gt;Interaction between locks and scheduling affects performance&lt;/li&gt;
&lt;li&gt;Lock tail latency may not affect application tail latency&lt;/li&gt;
&lt;li&gt;No single lock is systematically the best&lt;/li&gt;
&lt;li&gt;Choosing the best lock is difficult&lt;/li&gt;
&lt;li&gt;Energy efficiency and throughput go hand-in-hand in lock algorithms&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;The figure below is a guide for developers in selecting the appropriate lock considering
the findings of the the study.&lt;/p&gt;
&lt;img alt="" src="./images/jach/locks.png" style="width: 40%;" /&gt;
&lt;table class="docutils citation" frame="void" id="guerraoui2019" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[GUERRAOUI2019]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Guerraoui, R., Guiroux, H., Lachaize, R., Quéma, V., &amp;amp; Trigonakis, V. (2019). Lock–Unlock: Is That All? A Pragmatic Analysis of Locking in Software Systems. ACM Transactions on Computer Systems, 36(1), 1–149. &lt;a class="reference external" href="https://doi.org/10.1145/3301501"&gt;https://doi.org/10.1145/3301501&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content><category term="Paper Review"></category></entry><entry><title>Contiki - a Lightweight and Flexible Operating System for Tiny Networked Sensors</title><link href="https://srg-ics-uplb.github.io/blog/contiki-a-lightweight-and-flexible-operating-system-for-tiny-networked-sensors.html" rel="alternate"></link><published>2019-03-23T00:00:00+08:00</published><updated>2019-03-23T00:00:00+08:00</updated><author><name>Joseph Anthony C. Hermocilla</name></author><id>tag:srg-ics-uplb.github.io,2019-03-23:/blog/contiki-a-lightweight-and-flexible-operating-system-for-tiny-networked-sensors.html</id><summary type="html">&lt;p&gt;This paper &lt;a class="citation-reference" href="#dunkels2005" id="id1"&gt;[DUNKELS2005]&lt;/a&gt; describes the design and implementation of Contiki. The paper describes the characteristics of sensor
networks and its special requirements. These special requirements were considered in Contiki's design. For example,
nodes in sensor networks are tiny and limited in processing power and memory. Thus, Contiki should be able …&lt;/p&gt;</summary><content type="html">&lt;p&gt;This paper &lt;a class="citation-reference" href="#dunkels2005" id="id1"&gt;[DUNKELS2005]&lt;/a&gt; describes the design and implementation of Contiki. The paper describes the characteristics of sensor
networks and its special requirements. These special requirements were considered in Contiki's design. For example,
nodes in sensor networks are tiny and limited in processing power and memory. Thus, Contiki should be able to
run on these devices. Contiki is an event-driven operating system which means that it responds when an event happens.
The main components of Contiki are the kernel, libraries, program loader, and a set of processes.&lt;/p&gt;
&lt;table class="docutils citation" frame="void" id="dunkels2005" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[DUNKELS2005]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;ol class="first last upperalpha simple"&gt;
&lt;li&gt;Dunkels, B. Gronvall, and T. Voigt, “Contiki - a lightweight and flexible operating system for tiny networked sensors,” in 29th Annual IEEE International Conference on Local Computer Networks, 2004, pp. 455–462.&lt;/li&gt;
&lt;/ol&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content><category term="Paper Review"></category></entry><entry><title>Lecture Talk on Math in Action 2019</title><link href="https://srg-ics-uplb.github.io/blog/lecture-talk-on-math-in-action-2019.html" rel="alternate"></link><published>2019-03-05T00:00:00+08:00</published><updated>2019-03-05T00:00:00+08:00</updated><author><name>Miyah D. Queliste</name></author><id>tag:srg-ics-uplb.github.io,2019-03-05:/blog/lecture-talk-on-math-in-action-2019.html</id><summary type="html">&lt;p&gt;Miyah participated as one of the resource speakers in the Lecture Series of the recently concluded Math in Action 2019 last February 9-10, 2019. The event, organized by SAM-UP, a student academic organization in UPLB, was participated by students from different high schools nationwide. With this year's theme, &amp;quot;Connecting the …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Miyah participated as one of the resource speakers in the Lecture Series of the recently concluded Math in Action 2019 last February 9-10, 2019. The event, organized by SAM-UP, a student academic organization in UPLB, was participated by students from different high schools nationwide. With this year's theme, &amp;quot;Connecting the Dots Between Sustainable Innovation and Mathematics&amp;quot;, Miyah discussed about Mathematics' role in Robotics specifically in control systems. Most of the students are already familiar with drones and its applications. She emphasized the importance of the knowledge in Mathematical concepts such as integral and derivatives in designing controllers for drones and robots in general.&lt;/p&gt;
</content><category term="News"></category></entry><entry><title>How to contribute to this blog (Short Method)</title><link href="https://srg-ics-uplb.github.io/blog/how-to-contribute-to-this-blog-short-method.html" rel="alternate"></link><published>2019-02-02T00:00:00+08:00</published><updated>2019-03-06T00:00:00+08:00</updated><author><name>Joseph Anthony C. Hermocilla</name></author><id>tag:srg-ics-uplb.github.io,2019-02-02:/blog/how-to-contribute-to-this-blog-short-method.html</id><summary type="html">&lt;p&gt;This method is easier because the editing will be done in
github itself via the web browser.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Fork the original repository&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/srg-ics-uplb/blog"&gt;SRG Blog Repository&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This is accomplished in github and you must be logged in. You should have
the repository under your account after the fork. The succeeding steps …&lt;/p&gt;</summary><content type="html">&lt;p&gt;This method is easier because the editing will be done in
github itself via the web browser.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Fork the original repository&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/srg-ics-uplb/blog"&gt;SRG Blog Repository&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This is accomplished in github and you must be logged in. You should have
the repository under your account after the fork. The succeeding steps will be done on this forked repo.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. Create your entries&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If this is your first entry, you must create a folder for your articles.&lt;/p&gt;
&lt;p&gt;Navigate to  &lt;tt class="docutils literal"&gt;&amp;quot;contents/articles&amp;quot;&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Click the &lt;tt class="docutils literal"&gt;&amp;quot;Create new file button&amp;quot;&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Specify the file name of the first entry, say &lt;tt class="docutils literal"&gt;&amp;quot;clinton/clinton_001.rst&amp;quot;&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;You can begin writing your article. Save.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://docs.getpelican.com/en/3.6.3/content.html"&gt;Adding content&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/ralsina/rst-cheatsheet/blob/master/rst-cheatsheet.rst"&gt;More on RST Syntax&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For your succeeding articles, you can go directly to your own folder and
create the file there.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. Using images&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Navigate to  &lt;tt class="docutils literal"&gt;&amp;quot;contents/images&amp;quot;&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Upload your image, say &amp;quot;code.png&amp;quot;.&lt;/p&gt;
&lt;p&gt;To use your image in the article:&lt;/p&gt;
&lt;pre class="code html literal-block"&gt;
.. image:: ./images/code.png
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3. Make a pull request&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If your article is ready to be published, make a pull request.&lt;/p&gt;
</content><category term="HowTo's"></category></entry><entry><title>How to contribute to this blog (Long Method)</title><link href="https://srg-ics-uplb.github.io/blog/how-to-contribute-to-this-blog-long-method.html" rel="alternate"></link><published>2019-02-01T00:00:00+08:00</published><updated>2019-03-05T00:00:00+08:00</updated><author><name>Joseph Anthony C. Hermocilla</name></author><id>tag:srg-ics-uplb.github.io,2019-02-01:/blog/how-to-contribute-to-this-blog-long-method.html</id><summary type="html">&lt;p&gt;Contributions are encouraged from SRG members.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Set up the development environment&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ virtualenv pelican-blog-venv
$ &lt;span class="nb"&gt;source&lt;/span&gt; pelican-blog-venv/bin/activate
$ pip install pelican markdown ghp-import
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2. Fork the original repository&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/srg-ics-uplb/blog"&gt;SRG Blog Repository&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This is accomplished in github and you must be logged in. You should have
the repository under your account …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Contributions are encouraged from SRG members.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Set up the development environment&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ virtualenv pelican-blog-venv
$ &lt;span class="nb"&gt;source&lt;/span&gt; pelican-blog-venv/bin/activate
$ pip install pelican markdown ghp-import
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2. Fork the original repository&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/srg-ics-uplb/blog"&gt;SRG Blog Repository&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This is accomplished in github and you must be logged in. You should have
the repository under your account after the fork.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. Clone the repository from your account&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git clone https://github.com/&amp;lt;YOUR_USERNAME&amp;gt;/blog.git
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3. Configure a remote for your fork&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git remote -v
$ git remote add upstream https://github.com/srg-ics-uplb/blog.git
$ git remote -v
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a class="reference external" href="https://help.github.com/en/articles/configuring-a-remote-for-a-fork"&gt;Help: Create a remote&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. Sync your fork with the upstream&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git fetch upstream
$ git checkout master
$ git merge upstream/master
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a class="reference external" href="https://help.github.com/en/articles/syncing-a-fork"&gt;Help: Sync from upstream&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. Create your blog entry&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;At this point you are ready to write your entries. Create your own directory inside
content. You're going to place all your entries in this directory.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ mkdir -p content/&amp;lt;YOUR_NICKNAME&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For example, the source for this entry is &lt;a class="reference external" href="https://raw.githubusercontent.com/srg-ics-uplb/blog/master/content/articles/jach/jach_001.rst"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If your entry has images, place them in the images directory,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Additional Resources&lt;/strong&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://docs.getpelican.com/en/3.6.3/content.html"&gt;Adding content&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/ralsina/rst-cheatsheet/blob/master/rst-cheatsheet.rst"&gt;More on RST Syntax&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;img alt="" src="./images/jach/srg.png" style="width: 60pt;" /&gt;
</content><category term="HowTo's"></category></entry></feed>