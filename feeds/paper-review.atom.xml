<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Lost Packets - Paper Review</title><link href="https://srg-ics-uplb.github.io/blog/" rel="alternate"></link><link href="https://srg-ics-uplb.github.io/blog/feeds/paper-review.atom.xml" rel="self"></link><id>https://srg-ics-uplb.github.io/blog/</id><updated>2020-01-27T00:00:00+08:00</updated><entry><title>Fuzzing: Hack, Art, and Science</title><link href="https://srg-ics-uplb.github.io/blog/fuzzing-hack-art-and-science.html" rel="alternate"></link><published>2020-01-27T00:00:00+08:00</published><updated>2020-01-27T00:00:00+08:00</updated><author><name>Joseph Anthony C. Hermocilla</name></author><id>tag:srg-ics-uplb.github.io,2020-01-27:/blog/fuzzing-hack-art-and-science.html</id><summary type="html">&lt;p&gt;A program usually accepts input, performs operations on the input, and produces output.  Incorrect processing of input can lead to security vulnerabilities, such as buffer overflow. Depending on the input, the program may not perform the desired operation. An attacker can craft a specialized input that exploits the vulnerability to …&lt;/p&gt;</summary><content type="html">&lt;p&gt;A program usually accepts input, performs operations on the input, and produces output.  Incorrect processing of input can lead to security vulnerabilities, such as buffer overflow. Depending on the input, the program may not perform the desired operation. An attacker can craft a specialized input that exploits the vulnerability to take control of the machine running the vulnerable software.&lt;/p&gt;
&lt;p&gt;This paper [&lt;a class="reference internal" href="#godefroid2020"&gt;GODEFROID2020&lt;/a&gt;] gives an overview of fuzzing as a way to detect security vulnerabilities. Other approaches mentioned in the paper include the use of static program analyzers and manual code inspection. Fuzzing tests the behavior of a program against all, or a subset, of possible inputs to identify security vulnerabilities. It is an automated testing technique since there is a large set of possible inputs to a program.&lt;/p&gt;
&lt;p&gt;The paper discussed three fuzzing techniques. The first technique is called Blackbox Fuzzing. This technique uses well-formed inputs, mutates them, then use the mutated input to test the software.&lt;/p&gt;
&lt;p&gt;The second technique is Grammar-Based Fuzzing. This technique is useful if the input follows some form of structured formats such as JSON or XML. In this approach, the tester provides a grammar specifying the format. The fuzzer then generates input based on the provided grammar.&lt;/p&gt;
&lt;p&gt;The last technique is called Whitebox Fuzzing. This technique is more advanced since it uses dynamic symbolic execution. It gathers constraints on inputs as it executes a program from conditional branches. The constraints are negated and solved using a constraint solver. The solutions are then mapped to new inputs to pass through other execution paths in a program. SAGE is an example tool for Whitebox Fuzzing described in the paper.&lt;/p&gt;
&lt;p&gt;The conclusion is that the fuzzing technique to use depends on the type of program being tested. Programs that use binary input formats are best tested with Blackbox Fuzzing or Whitebox Fuzzing. Programs with more structured formats will benefit from Grammar-Based fuzzing.&lt;/p&gt;
&lt;table class="docutils citation" frame="void" id="godefroid2020" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[GODEFROID2020]&lt;/td&gt;&lt;td&gt;Patrice Godefroid. 2020. Fuzzing: hack, art, and science. Commun. ACM 63, 2 (January 2020), 70–76. DOI:https://doi.org/10.1145/3363824&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content><category term="Paper Review"></category></entry><entry><title>Cloud Benchmarking for Maximising Performance of Scientific Applications</title><link href="https://srg-ics-uplb.github.io/blog/cloud-benchmarking-for-maximising-performance-of-scientific-applications.html" rel="alternate"></link><published>2019-04-29T00:00:00+08:00</published><updated>2019-04-29T00:00:00+08:00</updated><author><name>Joseph Anthony C. Hermocilla</name></author><id>tag:srg-ics-uplb.github.io,2019-04-29:/blog/cloud-benchmarking-for-maximising-performance-of-scientific-applications.html</id><summary type="html">&lt;p&gt;It is quite difficult for users to select VM configurations to optimize the
performance of their applications, especially if there are a lot of choices.
For example, if I want to run computational chemistry app, I need to make a decision
whether to use a VM with 1 VCPU and …&lt;/p&gt;</summary><content type="html">&lt;p&gt;It is quite difficult for users to select VM configurations to optimize the
performance of their applications, especially if there are a lot of choices.
For example, if I want to run computational chemistry app, I need to make a decision
whether to use a VM with 1 VCPU and 2GB RAM or a VM with 2 VCPUs and 4GB RAM.&lt;/p&gt;
&lt;p&gt;Cloud providers run benchmarks to measure the performance of various VM configurations for applications.
However, these benchmarks are done independent of the application to be deployed. Most likely because
providers have no knowledge of what application will be deployed.&lt;/p&gt;
&lt;p&gt;This paper [&lt;a class="reference internal" href="#varghese2019"&gt;VARGHESE2019&lt;/a&gt;] addresses these issues by introducing an application-aware benchmarking
methodology. The main hypothesis presented in the paper is that by taking into account application
requirements in addition to benchmarking data, VMs can be ranked in order of performance and
cost-effectiveness to maximize performance. Although there are different kinds of applications
that can be run in the cloud, the paper focused on high-performance computing applications with
the goal of minimizing execution time to minimize costs. (Running applications in the cloud is
usually charged per hour.) The authors validated they results against real-world applications.
The following are the steps in the proposed methodology.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Capture attributes of cloud VMs&lt;/li&gt;
&lt;li&gt;Group attributes of cloud VMs&lt;/li&gt;
&lt;li&gt;Benckmark cloud VMs&lt;/li&gt;
&lt;li&gt;Normalize attribute groups&lt;/li&gt;
&lt;li&gt;Provide weights to groups&lt;/li&gt;
&lt;li&gt;Rank cloud VMs&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Steps 5-6 are repeated for each deployment.&lt;/p&gt;
&lt;p&gt;In Step 2, the following are the identified attribute groups:
- memory and process
- local communication
- computation
- storage&lt;/p&gt;
&lt;p&gt;As for the benchmarking part, the researchers used bonnie++, lmbench, and sysbench.&lt;/p&gt;
&lt;p&gt;It is worth noting that this paper did not consider inter-VM communication. The
local communication is between the cores in the VM only. Perhaps a future work will
be to consider inter-VM communication in the methodology.&lt;/p&gt;
&lt;table class="docutils citation" frame="void" id="varghese2019" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[VARGHESE2019]&lt;/td&gt;&lt;td&gt;Varghese, B., Akgun, O., Miguel, I., Thai, L., &amp;amp; Barker, A. (2019). Cloud Benchmarking for Maximising Performance of Scientific Applications. IEEE Transactions on Cloud Computing, 7(1), 170–182.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content><category term="Paper Review"></category></entry><entry><title>Lock–Unlock: Is That All? A Pragmatic Analysis of Locking in Software Systems</title><link href="https://srg-ics-uplb.github.io/blog/lock-unlock-is-that-all-a-pragmatic-analysis-of-locking-in-software-systems.html" rel="alternate"></link><published>2019-04-14T00:00:00+08:00</published><updated>2019-04-14T00:00:00+08:00</updated><author><name>Joseph Anthony C. Hermocilla</name></author><id>tag:srg-ics-uplb.github.io,2019-04-14:/blog/lock-unlock-is-that-all-a-pragmatic-analysis-of-locking-in-software-systems.html</id><summary type="html">&lt;p&gt;Most processors nowadays are multi-core processors to take advantage of parallel processing.
Associated with parallel processing is the synchronization problem wherein locks are extensively
used. This paper &lt;a class="citation-reference" href="#guerraoui2019" id="id1"&gt;[GUERRAOUI2019]&lt;/a&gt; argues that despite the large amount of available choices for
lock algorithms, developers do not have a comprehensive guide to select an …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Most processors nowadays are multi-core processors to take advantage of parallel processing.
Associated with parallel processing is the synchronization problem wherein locks are extensively
used. This paper &lt;a class="citation-reference" href="#guerraoui2019" id="id1"&gt;[GUERRAOUI2019]&lt;/a&gt; argues that despite the large amount of available choices for
lock algorithms, developers do not have a comprehensive guide to select an algorithm. The paper also
asserts that most research on lock algorithms are limited to mutex locks and rarely consider other
techniques like trylocks and condition variables. In addition, most evaluation of lock algorithms
use workload that are specific to the design of the lock. Lastly, evaluation is focused only on throughput
neglecting energy efficiency and tail latency.&lt;/p&gt;
&lt;p&gt;The main contribution of this paper is a broad performance study of lock algorithms. Specifically,
28 state-of-the-art algorithms were studied and applied to 40 applications. The experiments where
conducted of 4 different multi-core machines. As mentioned, this study considered energy efficiency and
tail latency, in addition to throughtput, as metrics in the evaluation. In the paper, the authors
claimed that it is really difficult to choose a well-performing lock for an application because of
several factors: workload, hardware, degree of parallelism, number of locks, how they are used, interaction
between the application and the CPU scheduler, and metric. The authors also developed a library called LiTL
used for testing the applications.&lt;/p&gt;
&lt;p&gt;The authors have the following observations as a result of their study&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Trylocks and condition variables should also be considered&lt;/li&gt;
&lt;li&gt;Memory footprint of lock algorithms affect performance&lt;/li&gt;
&lt;li&gt;Interaction between locks and scheduling affects performance&lt;/li&gt;
&lt;li&gt;Lock tail latency may not affect application tail latency&lt;/li&gt;
&lt;li&gt;No single lock is systematically the best&lt;/li&gt;
&lt;li&gt;Choosing the best lock is difficult&lt;/li&gt;
&lt;li&gt;Energy efficiency and throughput go hand-in-hand in lock algorithms&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;The figure below is a guide for developers in selecting the appropriate lock considering
the findings of the the study.&lt;/p&gt;
&lt;img alt="" src="./images/jach/locks.png" style="width: 40%;" /&gt;
&lt;table class="docutils citation" frame="void" id="guerraoui2019" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[GUERRAOUI2019]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Guerraoui, R., Guiroux, H., Lachaize, R., Quéma, V., &amp;amp; Trigonakis, V. (2019). Lock–Unlock: Is That All? A Pragmatic Analysis of Locking in Software Systems. ACM Transactions on Computer Systems, 36(1), 1–149. &lt;a class="reference external" href="https://doi.org/10.1145/3301501"&gt;https://doi.org/10.1145/3301501&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content><category term="Paper Review"></category></entry><entry><title>Contiki - a Lightweight and Flexible Operating System for Tiny Networked Sensors</title><link href="https://srg-ics-uplb.github.io/blog/contiki-a-lightweight-and-flexible-operating-system-for-tiny-networked-sensors.html" rel="alternate"></link><published>2019-03-23T00:00:00+08:00</published><updated>2019-03-23T00:00:00+08:00</updated><author><name>Joseph Anthony C. Hermocilla</name></author><id>tag:srg-ics-uplb.github.io,2019-03-23:/blog/contiki-a-lightweight-and-flexible-operating-system-for-tiny-networked-sensors.html</id><summary type="html">&lt;p&gt;This paper &lt;a class="citation-reference" href="#dunkels2005" id="id1"&gt;[DUNKELS2005]&lt;/a&gt; describes the design and implementation of Contiki. The paper describes the characteristics of sensor
networks and its special requirements. These special requirements were considered in Contiki's design. For example,
nodes in sensor networks are tiny and limited in processing power and memory. Thus, Contiki should be able …&lt;/p&gt;</summary><content type="html">&lt;p&gt;This paper &lt;a class="citation-reference" href="#dunkels2005" id="id1"&gt;[DUNKELS2005]&lt;/a&gt; describes the design and implementation of Contiki. The paper describes the characteristics of sensor
networks and its special requirements. These special requirements were considered in Contiki's design. For example,
nodes in sensor networks are tiny and limited in processing power and memory. Thus, Contiki should be able to
run on these devices. Contiki is an event-driven operating system which means that it responds when an event happens.
The main components of Contiki are the kernel, libraries, program loader, and a set of processes.&lt;/p&gt;
&lt;table class="docutils citation" frame="void" id="dunkels2005" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[DUNKELS2005]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;ol class="first last upperalpha simple"&gt;
&lt;li&gt;Dunkels, B. Gronvall, and T. Voigt, “Contiki - a lightweight and flexible operating system for tiny networked sensors,” in 29th Annual IEEE International Conference on Local Computer Networks, 2004, pp. 455–462.&lt;/li&gt;
&lt;/ol&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content><category term="Paper Review"></category></entry></feed>